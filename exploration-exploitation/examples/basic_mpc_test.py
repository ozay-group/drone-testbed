"""
basic_mpc_test.py
Description:
    This function tests the operation of one of the basic MPC formulations which uses an affine system.

"""

import numpy as np
import polytope as pc

import sys
sys.path.append('../classes/') # Add connection to the directory above this so that we have access to 'classes' directory and its contents.

import affinedynamics as ad
from mpc import AffineMPC

# Define Simple Discrete-Time Linear System
dim_x = 2
A = 1*np.eye(dim_x)
#A[0,1] = 0.2

dim_u = 2
B = np.eye(dim_u)

K1 = np.array([[1.0],[0.0]])

W1 = pc.box2poly([[-1,1],[-1,1]])

x0_0 = np.zeros((2,1))

affine_system2 = ad.AffineDynamics(A,B,W=W1,K=K1)

print(affine_system2)
affine_system2.print_matrices()

"""
Create MPC problem and try to solve with gurobi
"""

# Create state quadratic cost (Q) and input quadratic cost R
P0 = np.eye(dim_x)
P_T0 = P0
R0 = 0.01*np.eye(dim_u)
#R = np.zeros((dim_u,dim_u))

TimeHorizon_prime = 5
x_target = np.array([[1.0],[1.0]])

# Input Constraints
umin = -10
umax = 10
U0 = pc.box2poly([ [umin,umax] for i in range(0,dim_u) ])

u_star, cost_value, flags = AffineMPC( affine_system2 , TimeHorizon=TimeHorizon_prime , P=P0, P_T=P_T0, R=R0, x_target=np.kron(np.ones((1,TimeHorizon_prime)),x_target), U=U0 )

print('Obj: %g' % cost_value)
print('u*: ',u_star)

if u_star is not None:
    # Use Identified u to see if system reaches target
    x = np.zeros((dim_x,TimeHorizon_prime+1))
    x[:,0] = x0_0.flatten()
    for t in range(TimeHorizon_prime):
        #print(affine_system1.f(x[:,t].flatten(),u_star[t*dim_u:(t+1)*dim_u],flags="no_w"))

        x_tp1 = affine_system2.f(np.reshape(x[:,t],newshape=(dim_x,1)),np.reshape(u_star[t*dim_u:(t+1)*dim_u],newshape=(dim_u,1)),w=np.zeros(shape=(affine_system2.dim_w(),1)))
        x[:,t+1] = np.reshape( x_tp1 , newshape=(dim_x,))

    print( "x[:,-1] = " , x[:,-1] )

    S_w2, S_u2, S_x02, S_K2 = affine_system2.get_mpc_matrices(TimeHorizon_prime)
    print( "x_traj (according to mpc matrices) = " , np.dot(S_u2,np.matrix(u_star).T) + np.dot(S_x02,x0_0) + S_K2  )